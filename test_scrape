#!/usr/bin/env perl
use warnings;
use strict;

# allow the libs to be in the bin dir
use FindBin;
use lib "$FindBin::RealBin/lib";
use lib "/home/hamish/s/bin/lib";

use Data::Dumper;
$Data::Dumper::Indent = 1;
$Data::Dumper::Sortkeys = 1;
$Data::Dumper::Quotekeys = 0;

use HC::Common;

use HC::CredentialStore;
use HC::HackDB;

use CloudAtCostScrape;

my $option = {
    preset   => 'cac',
    verbose  => 0,
};
my @option_list = (
    "preset|s=s",
    "credfile=s",
    "verbose|v+",
    "debug!",
    "raw!",
);

sub data2hackdb {
    my $data = shift;
    return undef if (!$data);

    if (ref($data) eq 'HASH') {
        # assume that hashes are simply unique arrays and the key has no meaning
        my $newdata = qw();
        @{$newdata} = values(%{$data});
        $data = $newdata;
    }

    my $db = HC::HackDB->new();
    for my $data_row (@{$data}) {
        my $row = $db->empty_row();

        $row->set_from_hash($data_row);
        $db->add_row($row);
    }
    return $db;
}

sub cmd_buildstatus {
    my $cac = shift;

    return Dumper($cac->_siteFunctions_buildStatus());
}

sub cmd_listservers {
    my $cac = shift;

    my $data = $cac->_scrape_index();

    my $s = '';
    if ($option->{raw}) {
        $s .= "\n".Dumper($data)."\n";
    }

    $s .= "CustID: ". $data->{CustID} . "\n";

    my $hackdb = data2hackdb($data->{servers});
    $s .= $hackdb->extract(qw(id servername ipv4_address ipv6_address cpu ram ssd _status))->to_string_pretty();
    # cpu ram storage mode

    return $s;
}

sub cmd_listtemplates {
    my $cac = shift;
    my $data = $cac->_scrape_templates();

    my $s = '';
    if ($option->{raw}) {
        $s .= "\n".Dumper($data)."\n";
    }

    my $hackdb = data2hackdb($data->{data});
    $s .= $hackdb->extract(qw(id detail))->to_string_pretty();

    return $s;
}

sub cmd_todo {
    ...;
}

my $cmds = {
    'buildstatus'   => {
        cmd  => \&cmd_buildstatus,
        help => 'Return the current build status',
    },
    'listservers'   => {
        cmd  => \&cmd_listservers,
        help => 'Scape the server details',
    },
    'listtemplates'   => {
        cmd  => \&cmd_listtemplates,
        help => 'Scape the vm template details',
    },
    'build-cloud-pro' => {
        cmd  => \&cmd_todo,
        help => 'TODO',
    },
    'power' => {
        cmd  => \&cmd_todo,
        help => 'TODO',
    },
    'delete' => {
        cmd  => \&cmd_todo,
        help => 'TODO',
    },
    'renameserver' => {
        cmd  => \&cmd_todo,
        help => 'TODO',
    },
    'console' => {
        cmd  => \&cmd_todo,
        help => 'TODO',
    },
};


sub main() { 
    HC::Common::do_options($option,@option_list);
    if (defined($option->{help})) {
        print("Sub commands:\n\n");
        for my $cmd (sort(keys(%{$cmds}))) {
            printf("%-18s %s\n",$cmd,$cmds->{$cmd}{help});
        }
        return;
    }

    my ($username,$password);
    if (defined($option->{credfile})) {
        my $cred = HC::CredentialStore->new($option->{credfile});
        die("credfile error") if (!defined($cred));

        ($username,$password) = $cred->lookup($option->{preset});
    }

    die "Need username credentials" if (!defined($username));
    die "Need password credentials" if (!defined($password));

    my $cac = CloudAtCostScrape->new();
    if ($option->{debug}) {
        # TODO: perhaps create a debug method on the CloudAtCostScrape object
        $cac->Mech()->add_handler("request_send", sub { shift->dump; return });
        $cac->Mech()->add_handler("request_done", sub { shift->dump; return });
    }

    $cac->set_credentials($username,$password);

    my $cmd = shift(@ARGV);
    if (!defined($cmd) || !defined($cmds->{$cmd})) {
        die('No such sub-command');
    }

    my $result = $cmds->{$cmd}{'cmd'}($cac,@ARGV);;
    print($result);

}
main();

